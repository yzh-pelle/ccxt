using ccxt;
using ccxt.pro;
namespace Tests;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class BaseTest
{
        public void testKeysort()
        {
            var exchange = new ccxt.Exchange(new Dictionary<string, object>() {
                { "id", "sampleexchange" },
            });
            Assert("GO_SKIP_START");
            // Test 1: Basic key sorting
            object unsortedDict1 = new Dictionary<string, object>() {
                { "c", 3 },
                { "a", 1 },
                { "b", 2 },
            };
            object expectedSorted1 = new Dictionary<string, object>() {
                { "a", 1 },
                { "b", 2 },
                { "c", 3 },
            };
            object result1 = exchange.keysort(unsortedDict1);
            AssertDeepEqual(exchange, null, "testKeysort", new List<object>(((IDictionary<string,object>)result1).Keys), new List<object>(((IDictionary<string,object>)expectedSorted1).Keys));
            // Test 2: Already sorted dictionary
            object unsortedDict2 = new Dictionary<string, object>() {
                { "alpha", "first" },
                { "beta", "second" },
                { "gamma", "third" },
            };
            object expectedSorted2 = new Dictionary<string, object>() {
                { "alpha", "first" },
                { "beta", "second" },
                { "gamma", "third" },
            };
            object result2 = exchange.keysort(unsortedDict2);
            AssertDeepEqual(exchange, null, "testKeysort", new List<object>(((IDictionary<string,object>)result2).Keys), new List<object>(((IDictionary<string,object>)expectedSorted2).Keys));
            // Test 3: Reverse sorted input
            object unsortedDict3 = new Dictionary<string, object>() {
                { "z", "last" },
                { "n", "middle" },
                { "a", "first" },
            };
            object expectedSorted3 = new Dictionary<string, object>() {
                { "a", "first" },
                { "n", "middle" },
                { "z", "last" },
            };
            object result3 = exchange.keysort(unsortedDict3);
            AssertDeepEqual(exchange, null, "testKeysort", new List<object>(((IDictionary<string,object>)result3).Keys), new List<object>(((IDictionary<string,object>)expectedSorted3).Keys));
            // Test 4: Empty dictionary
            object unsortedDict4 = new Dictionary<string, object>() {};
            object expectedSorted4 = new Dictionary<string, object>() {};
            object result4 = exchange.keysort(unsortedDict4);
            AssertDeepEqual(exchange, null, "testKeysort", new List<object>(((IDictionary<string,object>)result4).Keys), new List<object>(((IDictionary<string,object>)expectedSorted4).Keys));
            // Test 5: Single key dictionary
            object unsortedDict5 = new Dictionary<string, object>() {
                { "only", "one" },
            };
            object expectedSorted5 = new Dictionary<string, object>() {
                { "only", "one" },
            };
            object result5 = exchange.keysort(unsortedDict5);
            AssertDeepEqual(exchange, null, "testKeysort", new List<object>(((IDictionary<string,object>)result5).Keys), new List<object>(((IDictionary<string,object>)expectedSorted5).Keys));
            // Test 6: Numeric string keys
            object unsortedDict6 = new Dictionary<string, object>() {
                { "10", "ten" },
                { "2", "two" },
                { "1", "one" },
            };
            object expectedSorted6 = new Dictionary<string, object>() {
                { "1", "one" },
                { "10", "ten" },
                { "2", "two" },
            };
            object result6 = exchange.keysort(unsortedDict6);
            AssertDeepEqual(exchange, null, "testKeysort", new List<object>(((IDictionary<string,object>)result6).Keys), new List<object>(((IDictionary<string,object>)expectedSorted6).Keys));
            // Test 7: Mixed case keys (lexicographic sort)
            object unsortedDict7 = new Dictionary<string, object>() {
                { "Banana", 1 },
                { "apple", 2 },
                { "Cherry", 3 },
            };
            object expectedSorted7 = new Dictionary<string, object>() {
                { "Banana", 1 },
                { "Cherry", 3 },
                { "apple", 2 },
            };
            object result7 = exchange.keysort(unsortedDict7);
            AssertDeepEqual(exchange, null, "testKeysort", new List<object>(((IDictionary<string,object>)result7).Keys), new List<object>(((IDictionary<string,object>)expectedSorted7).Keys));
            Assert("GO_SKIP_END");
            Assert(isEqual(exchange.safeString(null, "placeholder"), null)); // go trick
        }
}